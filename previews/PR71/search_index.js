var documenterSearchIndex = {"docs":
[{"location":"schema/#JSON-Schema-Generation-and-Validation","page":"JSON Schema","title":"JSON Schema Generation and Validation","text":"JSONSchema.jl provides a powerful, type-driven interface for generating JSON Schema v7 specifications from Julia types and validating instances against them. The system leverages Julia's type system and StructUtils annotations to provide a seamless schema definition experience.","category":"section"},{"location":"schema/#Quick-Start","page":"JSON Schema","title":"Quick Start","text":"using JSONSchema, StructUtils\n\n# Define a struct with field tag annotations\n@defaults struct User\n    id::Int = 0 &(json=(\n        description=\"Unique user ID\",\n        minimum=1\n    ),)\n\n    name::String = \"\" &(json=(\n        description=\"User's full name\",\n        minLength=1,\n        maxLength=100\n    ),)\n\n    email::String = \"\" &(json=(\n        description=\"Email address\",\n        format=\"email\"\n    ),)\n\n    age::Union{Int, Nothing} = nothing &(json=(\n        description=\"User's age\",\n        minimum=0,\n        maximum=150\n    ),)\nend\n\n# Generate the JSON Schema\nschema = JSONSchema.schema(User)\n\n# Validate an instance\nuser = User(1, \"Alice\", \"alice@example.com\", 30)\nresult = JSONSchema.validate(schema, user)\n\nif result.is_valid\n    println(\"User is valid!\")\nelse\n    println(\"Validation errors:\")\n    foreach(println, result.errors)\nend","category":"section"},{"location":"schema/#API","page":"JSON Schema","title":"API","text":"","category":"section"},{"location":"schema/#JSONSchema.schema(T;-options...)","page":"JSON Schema","title":"JSONSchema.schema(T; options...)","text":"Generate a JSON Schema for type T.\n\nParameters:\n\nT::Type: The Julia type to generate a schema for.\ntitle::String: Schema title (defaults to type name).\ndescription::String: Schema description.\nrefs::Bool: If true, generates definitions for nested types and uses $ref pointers. Essential for circular references or shared types.\nall_fields_required::Bool: If true, marks all fields as required (overriding Union{T, Nothing} behavior).\nadditionalProperties::Bool: Recursively sets additionalProperties on all objects.\n\nReturns: A Schema{T} object.","category":"section"},{"location":"schema/#JSONSchema.validate(schema,-instance)","page":"JSON Schema","title":"JSONSchema.validate(schema, instance)","text":"Validate a Julia instance against the schema.\n\nReturns: A ValidationResult struct:\n\nis_valid::Bool: true if validation passed.\nerrors::Vector{String}: A list of error messages if validation failed.","category":"section"},{"location":"schema/#JSONSchema.isvalid(schema,-instance;-verbosefalse)","page":"JSON Schema","title":"JSONSchema.isvalid(schema, instance; verbose=false)","text":"Convenience function that returns a Bool.\n\nverbose=true: Prints validation errors to stdout.","category":"section"},{"location":"schema/#Validation-Features","page":"JSON Schema","title":"Validation Features","text":"Validation rules are specified using StructUtils field tags with the json key.","category":"section"},{"location":"schema/#String-Validation","page":"JSON Schema","title":"String Validation","text":"minLength::Int, maxLength::Int\npattern::String (Regex)\nformat::String:\n\"email\": Basic email validation (no spaces).\n\"uri\": URI validation (requires scheme).\n\"uuid\": UUID validation.\n\"date-time\": ISO 8601 date-time (requires timezone, e.g., 2023-01-01T12:00:00Z).","category":"section"},{"location":"schema/#Numeric-Validation","page":"JSON Schema","title":"Numeric Validation","text":"minimum::Number, maximum::Number\nexclusiveMinimum::Bool|Number, exclusiveMaximum::Bool|Number\nmultipleOf::Number","category":"section"},{"location":"schema/#Array-Validation","page":"JSON Schema","title":"Array Validation","text":"minItems::Int, maxItems::Int\nuniqueItems::Bool\ncontains: A schema that at least one item in the array must match.","category":"section"},{"location":"schema/#Composition-(Advanced)","page":"JSON Schema","title":"Composition (Advanced)","text":"oneOf: Value must match exactly one of the provided schemas.\nanyOf: Value must match at least one of the provided schemas.\nallOf: Value must match all of the provided schemas.\nnot: Value must not match the provided schema.\n\nExample:\n\n# Value must be either a string OR an integer (oneOf)\nval::Union{String, Int} = 0\n\n# Advanced composition via manual tags\nvalue::Int = 0 &(json=(\n    oneOf=[\n        Dict(\"minimum\" => 0, \"maximum\" => 10),\n        Dict(\"minimum\" => 100, \"maximum\" => 110)\n    ]\n),)","category":"section"},{"location":"schema/#Conditional-Logic","page":"JSON Schema","title":"Conditional Logic","text":"if, then, else: Apply schemas conditionally based on the result of the if schema.","category":"section"},{"location":"schema/#Handling-Complex-Types","page":"JSON Schema","title":"Handling Complex Types","text":"","category":"section"},{"location":"schema/#Recursive-and-Shared-Types-(refstrue)","page":"JSON Schema","title":"Recursive & Shared Types (refs=true)","text":"By default, schemas are inlined. For complex data models with shared subtypes or circular references (e.g., A -> B -> A), use refs=true.\n\n@defaults struct Node\n    value::Int = 0\n    children::Vector{Node} = Node[]\nend\n\n# Generates a schema with \"definitions\" and \"$ref\" recursion\nschema = JSONSchema.schema(Node, refs=true)","category":"section"},{"location":"schema/#Type-Mapping","page":"JSON Schema","title":"Type Mapping","text":"Julia Type JSON Schema Type Notes\nInt, Float64 \"integer\", \"number\" \nString \"string\" \nBool \"boolean\" \nNothing, Missing \"null\" \nUnion{T, Nothing} [T, \"null\"] Automatically optional\nVector{T} \"array\" items = schema of T\nSet{T} \"array\" uniqueItems: true\nDict{K,V} \"object\" additionalProperties = schema of V\nTuple{...} \"array\" Fixed length, positional types\nCustom Struct \"object\" Properties map to fields","category":"section"},{"location":"schema/#Best-Practices","page":"JSON Schema","title":"Best Practices","text":"Use JSONSchema.validate for APIs: It provides programmatic access to error messages, which is essential for reporting validation failures to users.\nUse Enums: enum=[\"a\", \"b\"] is often stricter and better than free-form strings.\nUse refs=true for Libraries: If you are generating schemas for a library of types, using references keeps the schema size smaller and more readable.\nBe Specific with Formats: The date-time format is strict (ISO 8601 with timezone). Ensure your data complies.","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#JSONSchema.ValidationResult","page":"API Reference","title":"JSONSchema.ValidationResult","text":"ValidationResult\n\nResult of a schema validation operation.\n\nFields\n\nis_valid::Bool: Whether the validation was successful\nerrors::Vector{String}: List of validation error messages (empty if valid)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.isvalid-Union{Tuple{T}, Tuple{Schema{T}, T}} where T","page":"API Reference","title":"Base.isvalid","text":"Base.isvalid(schema::Schema{T}, instance::T; verbose=false) -> Bool\n\nValidate that instance satisfies all constraints defined in schema.\n\nThis function extends Base.isvalid and checks that the instance meets all validation requirements specified in the schema's field tags, including:\n\nString constraints (minLength, maxLength, pattern, format)\nNumeric constraints (minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf)\nArray constraints (minItems, maxItems, uniqueItems)\nEnum and const values\nNested struct validation\n\nArguments\n\nschema::Schema{T}: The schema to validate against\ninstance::T: The instance to validate\nverbose::Bool=false: If true, print detailed validation errors to stdout\n\nReturns\n\ntrue if the instance is valid, false otherwise\n\nExample\n\nusing JSONSchema, StructUtils\n\n@defaults struct User\n    name::String = \"\" &(json=(minLength=1, maxLength=100),)\n    age::Int = 0 &(json=(minimum=0, maximum=150),)\nend\n\nschema = JSONSchema.schema(User)\nuser1 = User(\"Alice\", 25)\nuser2 = User(\"\", 200)  # Invalid: empty name, age too high\n\nisvalid(schema, user1)  # true\nisvalid(schema, user2)  # false\nisvalid(schema, user2; verbose=true)  # false, with error messages\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema._validate_required_for_dict-Tuple{Any, AbstractDict, String, Vector{String}}","page":"API Reference","title":"JSONSchema._validate_required_for_dict","text":"_validate_required_for_dict(schema, value::AbstractDict, path, errors)\n\nValidate required fields for Dict values, even when properties is not defined. This restores v1.5.0 behavior where required was checked independently.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.defs_key_name-Tuple{Symbol}","page":"API Reference","title":"JSONSchema.defs_key_name","text":"defs_key_name(defs_location::Symbol) -> String\n\nGet the proper key name for definitions/defs. Converts :defs to \"defs\" and :definitions to \"definitions\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.diagnose-Tuple{Any, Any}","page":"API Reference","title":"JSONSchema.diagnose","text":"diagnose(x, schema)\n\nwarning: Deprecated\ndiagnose(x, schema) is deprecated. Use validate(schema, x) instead.\n\nValidate x against schema and return a string description of the first error, or nothing if valid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.schema-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"JSONSchema.schema","text":"schema(T::Type; title=nothing, description=nothing, id=nothing, draft=\"https://json-schema.org/draft-07/schema#\", all_fields_required=false, additionalProperties=nothing)\n\nGenerate a JSON Schema for type T. The schema is returned as a JSON-serializable Object.\n\nKeyword Arguments\n\nall_fields_required::Bool=false: If true, all fields of object schemas will be added to the required list.\nadditionalProperties::Union{Nothing,Bool}=nothing: If true or false, sets additionalProperties recursively on the root and all child object schemas. If nothing, no additional action is taken.\n\nField-level schema properties can be specified using StructUtils field tags with the json key:\n\nExample\n\n@defaults struct User\n    id::Int = 0 &(json=(\n        description=\"Unique user identifier\",\n        minimum=1\n    ),)\n    name::String = \"\" &(json=(\n        description=\"User's full name\",\n        minLength=1,\n        maxLength=100\n    ),)\n    email::Union{String, Nothing} = nothing &(json=(\n        description=\"Email address\",\n        format=\"email\"\n    ),)\n    age::Union{Int, Nothing} = nothing &(json=(\n        minimum=0,\n        maximum=150,\n        exclusiveMaximum=false\n    ),)\nend\n\nschema = JSON.schema(User)\n\nSupported Field Tag Properties\n\nString validation\n\nminLength::Int: Minimum string length\nmaxLength::Int: Maximum string length\npattern::String: Regular expression pattern (ECMA-262)\nformat::String: Format hint (e.g., \"email\", \"uri\", \"date-time\", \"uuid\")\n\nNumeric validation\n\nminimum::Number: Minimum value (inclusive)\nmaximum::Number: Maximum value (inclusive)\nexclusiveMinimum::Bool|Number: Exclusive minimum\nexclusiveMaximum::Bool|Number: Exclusive maximum\nmultipleOf::Number: Value must be multiple of this\n\nArray validation\n\nminItems::Int: Minimum array length\nmaxItems::Int: Maximum array length\nuniqueItems::Bool: All items must be unique\n\nObject validation\n\nminProperties::Int: Minimum number of properties\nmaxProperties::Int: Maximum number of properties\n\nGeneric\n\ndescription::String: Human-readable description\ntitle::String: Short title for the field\ndefault::Any: Default value\nexamples::Vector: Example values\n_const::Any: Field must have this exact value (use _const since const is a reserved keyword)\nenum::Vector: Field must be one of these values\nrequired::Bool: Override required inference (default: true for non-Union{T,Nothing} types)\n\nComposition\n\nallOf::Vector{Type}: Must validate against all schemas\nanyOf::Vector{Type}: Must validate against at least one schema\noneOf::Vector{Type}: Must validate against exactly one schema\n\nThe function automatically:\n\nMaps Julia types to JSON Schema types\nMarks non-Nothing union fields as required\nHandles nested types and arrays\nSupports custom types via registered converters\n\nReturns\n\nA Schema{T} object that contains both the type information and the JSON Schema specification. The schema can be used for validation with JSON.isvalid(schema, instance).\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.should_use_ref-Union{Tuple{T}, Tuple{Type{T}, Union{Nothing, SchemaContext}}} where T","page":"API Reference","title":"JSONSchema.should_use_ref","text":"should_use_ref(::Type{T}, ctx::Union{Nothing, SchemaContext}) -> Bool\n\nDetermine if a type should be referenced via ref instead of inlined.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.type_to_ref_name-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"JSONSchema.type_to_ref_name","text":"type_to_ref_name(::Type{T}) -> String\n\nGenerate a reference name for a type. Uses fully qualified names for disambiguation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JSONSchema.validate-Union{Tuple{T}, Tuple{Schema{T}, T}} where T","page":"API Reference","title":"JSONSchema.validate","text":"validate(schema::Schema{T}, instance::T) -> Union{Nothing, ValidationResult}\n\nValidate that instance satisfies all constraints defined in schema. Returns nothing if valid, or a ValidationResult containing error messages if invalid.\n\nExample\n\nresult = validate(schema, instance)\nif result !== nothing\n    for err in result.errors\n        println(err)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"#JSONSchema.jl","page":"Home","title":"JSONSchema.jl","text":"JSONSchema.jl generates JSON Schema (draft-07) from Julia types and validates instances against those schemas. It also supports validating data against hand-written JSON Schema objects.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"JSONSchema\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using JSONSchema\nusing StructUtils\n\n@defaults struct User\n    id::Int = 0\n    name::String = \"\" &(json=(minLength=1,),)\n    email::String = \"\" &(json=(format=\"email\",),)\n    age::Union{Int, Nothing} = nothing\nend\n\nschema = JSONSchema.schema(User)\nuser = User(1, \"Alice\", \"alice@example.com\", 30)\nresult = JSONSchema.validate(schema, user)\n\nresult.is_valid","category":"section"},{"location":"migration/#v2.0-Migration-Guide","page":"v2.0 Migration Guide","title":"v2.0 Migration Guide","text":"This guide helps you upgrade from JSONSchema.jl v1.x to v2.0. The v2.0 release is a complete rewrite that changes the package from a pure validation library to a schema generation and validation library.","category":"section"},{"location":"migration/#Overview-of-Changes","page":"v2.0 Migration Guide","title":"Overview of Changes","text":"JSONSchema.jl v2.0 introduces:\n\nSchema generation from Julia types via schema(T)\nType-safe validation with Schema{T}\nStructUtils integration for field-level validation rules\n$ref support for schema deduplication\n\nMost v1.x code will continue to work with minimal changes thanks to our backwards compatibility layer.","category":"section"},{"location":"migration/#Breaking-Changes","page":"v2.0 Migration Guide","title":"Breaking Changes","text":"","category":"section"},{"location":"migration/#1.-parent_dir-Keyword-Argument-Removed","page":"v2.0 Migration Guide","title":"1. parent_dir Keyword Argument Removed","text":"The Schema constructor no longer accepts a parent_dir keyword argument for resolving local file $ref references.\n\nv1.x:\n\nschema = Schema(spec; parent_dir=\"./schemas\")\n\nv2.0: Local file reference resolution is not currently supported. External $ref references should be resolved before creating the schema, or use the new refs keyword argument with schema() for type-based deduplication.","category":"section"},{"location":"migration/#2.-SingleIssue-Type-Replaced-by-ValidationResult","page":"v2.0 Migration Guide","title":"2. SingleIssue Type Replaced by ValidationResult","text":"The SingleIssue type from v1.x has been replaced by ValidationResult. For backwards compatibility, SingleIssue is aliased to ValidationResult, so existing isa checks will continue to work.\n\nv1.x:\n\nresult = validate(schema, data)\nif result isa SingleIssue\n    println(result.x)       # The invalid value\n    println(result.path)    # JSON path to the error\nend\n\nv2.0:\n\nresult = validate(schema, data)\nif result !== nothing\n    for err in result.errors\n        println(err)  # Error message with path\n    end\nend","category":"section"},{"location":"migration/#API-Compatibility","page":"v2.0 Migration Guide","title":"API Compatibility","text":"The following v1.x patterns are fully supported in v2.0:","category":"section"},{"location":"migration/#validate()-Return-Type-(Unchanged)","page":"v2.0 Migration Guide","title":"validate() Return Type (Unchanged)","text":"The validate function returns nothing on success and a ValidationResult on failure, matching v1.x behavior:\n\nresult = validate(schema, data)\nif result === nothing\n    println(\"Valid!\")\nelse\n    for err in result.errors\n        println(err)\n    end\nend","category":"section"},{"location":"migration/#isvalid()-Function","page":"v2.0 Migration Guide","title":"isvalid() Function","text":"The isvalid function extends Base.isvalid and returns a boolean:\n\nusing JSONSchema\n\nisvalid(schema, data)  # Returns true or false","category":"section"},{"location":"migration/#schema.data-Field-Access","page":"v2.0 Migration Guide","title":"schema.data Field Access","text":"schema = Schema(Dict(\"type\" => \"object\"))\nschema.data[\"type\"]  # Works - maps to schema.spec","category":"section"},{"location":"migration/#Boolean-Schemas","page":"v2.0 Migration Guide","title":"Boolean Schemas","text":"Schema(true)   # Accepts everything\nSchema(false)  # Rejects everything","category":"section"},{"location":"migration/#Inverse-Argument-Order","page":"v2.0 Migration Guide","title":"Inverse Argument Order","text":"validate(data, schema)  # Works - swaps to validate(schema, data)\nisvalid(data, schema)   # Works - swaps to isvalid(schema, data)","category":"section"},{"location":"migration/#required-Without-properties","page":"v2.0 Migration Guide","title":"required Without properties","text":"schema = Schema(Dict(\"type\" => \"object\", \"required\" => [\"foo\"]))\nisvalid(schema, Dict(\"bar\" => 1))  # Returns false (v1.x behavior)","category":"section"},{"location":"migration/#diagnose-Function-(Deprecated)","page":"v2.0 Migration Guide","title":"diagnose Function (Deprecated)","text":"diagnose(data, schema)  # Works but emits deprecation warning\n\nUse validate(schema, data) instead.","category":"section"},{"location":"migration/#New-Features-in-v2.0","page":"v2.0 Migration Guide","title":"New Features in v2.0","text":"","category":"section"},{"location":"migration/#Schema-Generation-from-Types","page":"v2.0 Migration Guide","title":"Schema Generation from Types","text":"Generate JSON Schema directly from Julia struct definitions:\n\nusing JSONSchema, StructUtils\n\n@defaults struct User\n    id::Int = 0 &(json=(minimum=1,),)\n    name::String = \"\" &(json=(minLength=1, maxLength=100),)\n    email::String = \"\" &(json=(format=\"email\",),)\n    age::Union{Int, Nothing} = nothing &(json=(minimum=0, maximum=150),)\nend\n\nschema = JSONSchema.schema(User)","category":"section"},{"location":"migration/#Type-Safe-Validation","page":"v2.0 Migration Guide","title":"Type-Safe Validation","text":"Schemas are now parameterized by the type they describe:\n\nschema = JSONSchema.schema(User)  # Returns Schema{User}\nuser = User(1, \"Alice\", \"alice@example.com\", 30)\nisvalid(schema, user)  # Type-safe validation","category":"section"},{"location":"migration/#ref-Support-for-Deduplication","page":"v2.0 Migration Guide","title":"$ref Support for Deduplication","text":"Use refs=true to generate schemas with $ref for nested types:\n\n@defaults struct Address\n    street::String = \"\"\n    city::String = \"\"\nend\n\n@defaults struct Person\n    name::String = \"\"\n    address::Address = Address()\nend\n\nschema = JSONSchema.schema(Person, refs=true)\n# Generates schema with `$ref` to #/definitions/Address","category":"section"},{"location":"migration/#ValidationResult-with-Error-Details","page":"v2.0 Migration Guide","title":"ValidationResult with Error Details","text":"Get detailed validation errors:\n\nresult = JSONSchema.validate(schema, invalid_data)\nif result !== nothing\n    for error in result.errors\n        println(error)  # e.g., \"name: string length 0 is less than minimum 1\"\n    end\nend","category":"section"},{"location":"migration/#Quick-Migration-Checklist","page":"v2.0 Migration Guide","title":"Quick Migration Checklist","text":"[ ] Remove parent_dir keyword from Schema() calls\n[ ] Update error handling to use ValidationResult.errors instead of SingleIssue fields\n[ ] Consider using schema(T) for type-based schema generation","category":"section"},{"location":"migration/#Getting-Help","page":"v2.0 Migration Guide","title":"Getting Help","text":"If you encounter issues migrating, please open an issue with details about your use case.","category":"section"}]
}
